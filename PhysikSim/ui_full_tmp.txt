import tkinter as tk
from tkinter import ttk
from tkinter import font as tkfont
from tkinter import filedialog
import matplotlib
# Embed matplotlib using the TkAgg backend
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib import animation
import matplotlib.pyplot as plt
plt.style.use('dark_background')
import numpy as np
import datetime
import time
import os
from save_projection_svg import export_projections
try:
    from PIL import ImageGrab  # type: ignore
except Exception:  # Pillow is optional; screenshot feature will fail gracefully
    ImageGrab = None
from ui_utils import set_state_recursive

# ---------------------------------------------------------------------------
# Theme configuration
# ---------------------------------------------------------------------------
DARK_BG = "#121212"
AX_BG = "#000000"
FG_COLOR = "#ffffff"
ACCENT_BG = "#444444"

# Status colours for future messages
STATUS_SUCCESS = "#2ecc71"  # green
STATUS_WARNING = "#ff8c00"  # orange

# Spacing and rounding parameters
PADDING = 8
BORDER_RADIUS = 6
TARGET_FPS = 30
MAX_TRAIL_POINTS = 1000


def configure_fonts() -> None:
    """Load preferred fonts and apply them globally."""

    preferred = ("Inter", "Roboto")
    default_font = tkfont.nametofont("TkDefaultFont")
    for family in preferred:
        try:
            tkfont.Font(family=family)
            default_font.configure(family=family)
            break
        except tk.TclError:
            continue

    for name in ("TkTextFont", "TkMenuFont", "TkHeadingFont"):
        try:
            tkfont.nametofont(name).configure(
                family=default_font.cget("family")
            )
        except tk.TclError:
            pass


def configure_theme(root: tk.Tk) -> ttk.Style:
    """Configure ttk styles based on the central palette."""

    style = ttk.Style(root)
    style.theme_use("clam")

    style.configure("TFrame", background=DARK_BG, padding=PADDING)
    style.configure("TLabel", background=DARK_BG, foreground=FG_COLOR, padding=PADDING)
    style.configure(
        "TLabelFrame", background=DARK_BG, foreground=FG_COLOR, padding=PADDING
    )
    style.configure(
        "Black.TLabelframe",
        background="#000000",
        foreground=FG_COLOR,
        padding=PADDING,
    )
    style.configure(
        "TCheckbutton", background=DARK_BG, foreground=FG_COLOR, padding=PADDING
    )
    style.configure(
        "TButton",
        background=ACCENT_BG,
        foreground=FG_COLOR,
        padding=PADDING,
        borderwidth=0,
    )
    style.configure(
        "TEntry",
        fieldbackground=ACCENT_BG,
        foreground=FG_COLOR,
        insertcolor=FG_COLOR,
        padding=PADDING,
    )
    style.configure(
        "TCombobox",
        fieldbackground=ACCENT_BG,
        background=DARK_BG,
        foreground=FG_COLOR,
        padding=PADDING,
    )

    style.configure("TNotebook", background=DARK_BG)
    style.configure(
        "TNotebook.Tab",
        background=ACCENT_BG,
        foreground=FG_COLOR,
        padding=PADDING,
    )

    try:
        style.configure(".", borderRadius=BORDER_RADIUS)
    except tk.TclError:
        pass

    return style


class Tooltip:
    """Lightweight tooltip that appears when hovering over a widget."""

    def __init__(self, widget: tk.Widget, text: str) -> None:
        self.widget = widget
        self.text = text
        self.tipwindow: tk.Toplevel | None = None
        widget.bind("<Enter>", self.show_tooltip)
        widget.bind("<Leave>", self.hide_tooltip)

    def show_tooltip(self, event: tk.Event | None = None) -> None:
        if self.tipwindow is not None:
            return
        x = self.widget.winfo_rootx() + 20
        y = self.widget.winfo_rooty() + self.widget.winfo_height() + 10
        self.tipwindow = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(
            tw,
            text=self.text,
            justify="left",
            background="#ffffe0",
            relief="solid",
            borderwidth=1,
            font=("TkDefaultFont", 10),
        )
        label.pack(ipadx=1)

    def hide_tooltip(self, event: tk.Event | None = None) -> None:
        if self.tipwindow is not None:
            self.tipwindow.destroy()
            self.tipwindow = None


def main():
    root = tk.Tk()
    root.title("PhysikSim")

    configure_fonts()
    style = configure_theme(root)
    root.configure(bg=DARK_BG)
    # Start with a window sized relative to the display and maximize when possible.
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    width = int(screen_width * 0.8)
    height = int(screen_height * 0.8)
    root.geometry(f"{width}x{height}")
    try:
        root.state("zoomed")
    except tk.TclError:
        pass
    # Ensure a sensible minimum size so controls and plots do not overlap on
    # common displays.
    root.minsize(1280, 800)

    # Grid layout: row 0 holds the top bar and row 1 is split into
    # a sidebar (column 0) and the main display area (column 1).
    root.rowconfigure(0, weight=0)
    root.rowconfigure(1, weight=1)
    root.columnconfigure(0, weight=0)
    root.columnconfigure(1, weight=1)

    # Automatically scale fonts with window size.
    default_fonts = [tkfont.nametofont(name)
                     for name in ("TkDefaultFont", "TkTextFont",
                                 "TkMenuFont", "TkHeadingFont")]
    slider_font = tkfont.Font(size=12)
    desc_font = tkfont.Font(size=10)
    inputs: list[ttk.Entry] = []
    desc_label: ttk.Label | None = None
    run_play_btn = None
    pendulum_export_button = None
    diagram_export_button = None
    MAX_BUTTON_WIDTH = 12
    last_font_size = None
    last_slider_font_size = None
    last_desc_font_size = None
    screenshot_taken = False
    pendulum_data: dict[str, np.ndarray] | None = None
    running = False
    has_run = False
    def resize_ui(event):
        """Adjust fonts when the window size changes."""
        nonlocal last_font_size, last_slider_font_size, last_desc_font_size
        # Only handle resize events triggered by the root window itself
        if event.widget is not root:
            return
        size = max(8, int(min(event.width, event.height) / 50))

        if size != last_font_size:
            for f in default_fonts:
                f.configure(size=size)
            last_font_size = size

        desc_size = max(8, size - 2)
        if desc_size != last_desc_font_size:
            desc_font.configure(size=desc_size)
            last_desc_font_size = desc_size

        entry_size = min(int(size * 1.4), 32)
        if entry_size != last_slider_font_size:
            slider_font.configure(size=entry_size)
            for e in inputs:
                e.configure(font=slider_font)
            last_slider_font_size = entry_size

        if desc_label is not None:
            desc_label.configure(wraplength=int(root.winfo_width() * 0.3) - 20)
        if run_play_btn is not None:
            btn_width = min(MAX_BUTTON_WIDTH, max(1, event.width // 30))
            if pendulum_export_button is not None:
                pendulum_export_button.configure(width=btn_width)
            if diagram_export_button is not None:
                diagram_export_button.configure(width=btn_width)


    root.bind("<Configure>", resize_ui)

    def take_screenshot():
        selection = option_var.get()
        if selection == "3D Pendulum":
            params = dict(
                L=l_var.get(),
                theta0=np.radians(phi_var.get()),
                phi0=np.radians(psi_var.get()),
                phi_dot0=np.radians(psi_dot_var.get()),
                g=g_var.get(),
                h=h_var.get(),
                t_final=pendulum_data["t"][-1] if pendulum_data is not None else 30.0,
                air_resistance=drag_var.get(),
                force_x=force_x_var.get(),
                force_y=force_y_var.get(),
                force_z=force_z_var.get(),
            )
            export_projections(**params)
        else:
            if ImageGrab is None:
                print("Pillow not available, cannot take screenshot.")
                return
            x = root.winfo_rootx()
            y = root.winfo_rooty()
            w = root.winfo_width()
            h = root.winfo_height()
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            ImageGrab.grab(bbox=(x, y, x + w, y + h)).save(
                f"screenshot_{timestamp}.png"
            )

    def auto_screenshot():
        nonlocal screenshot_taken
        if not screenshot_taken:
            screenshot_taken = True
            take_screenshot()

    def export_pendulum():
        selection = option_var.get()
        if selection == "3D Pendulum":
            file_path = filedialog.asksaveasfilename(
                defaultextension=".svg",
                filetypes=[("SVG files", "*.svg")],
                title="Pendel exportieren",
            )
            if not file_path:
                return
            base, _ = os.path.splitext(file_path)
            params = dict(
                L=l_var.get(),
                theta0=np.radians(phi_var.get()),
                phi0=np.radians(psi_var.get()),
                phi_dot0=np.radians(psi_dot_var.get()),
                g=g_var.get(),
                h=h_var.get(),
                t_final=pendulum_data["t"][-1] if pendulum_data is not None else 30.0,
                air_resistance=drag_var.get(),
                force_x=force_x_var.get(),
                force_y=force_y_var.get(),
                force_z=force_z_var.get(),
            )
            export_projections(
                out_floor=base + "_floor.svg",
                out_wall=base + "_wall.svg",
                **params,
            )
        else:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("SVG files", "*.svg")],
                title="Pendel exportieren",
            )
            if not file_path:
                return
            fig_anim.savefig(file_path, facecolor=fig_anim.get_facecolor())

    def export_plot():
        file_path = filedialog.asksaveasfilename(
            defaultextension=".png",
            filetypes=[("PNG files", "*.png"), ("SVG files", "*.svg")],
            title="Diagramm exportieren",
        )
        if not file_path:
            return
        fig_plot.savefig(file_path, facecolor=fig_plot.get_facecolor())

    def apply_impulse():
        """Apply an impulse to the running 3D pendulum simulation."""
        if option_var.get() != "3D Pendulum" or pendulum_data is None:
            return
        if pendulum_data.get("frame") is None:
            return

        import pendulum3d as mod

        frame = int(pendulum_data["frame"])
        t = pendulum_data["t"]
        if frame >= len(t) - 1:
            return

        L_val = l_var.get()
        g_val = g_var.get()
        h = h_var.get()
        drag_val = drag_var.get()
        fx = force_x_var.get()
        fy = force_y_var.get()
        fz = force_z_var.get()
        theta = pendulum_data["Angle"]
        psi = pendulum_data["Psi"]
        theta_dot = pendulum_data["Angular velocity"]
        phi_dot = pendulum_data["phi_dot"]
        remaining = len(t) - frame
        t_final = (remaining - 1) * h

        (
            _t_new,
            theta_new,
            psi_new,
            theta_dot_new,
            phi_dot_new,
            energy_new,
        ) = mod.run(
            L=L_val,
            theta0=theta[frame],
            phi0=psi[frame],
            theta_dot0=theta_dot[frame],
            phi_dot0=phi_dot[frame],
            g=g_val,
            h=h,
            air_resistance=drag_val,
            force_x=fx,
            force_y=fy,
            force_z=fz,
            t_final=t_final,
            plot=False,
        )

        x = pendulum_data["x"]
        y = pendulum_data["y"]
        z = pendulum_data["z"]
        vx = pendulum_data["vx"]
        vy = pendulum_data["vy"]
        vz = pendulum_data["vz"]

        x_new = L_val * np.sin(theta_new) * np.cos(psi_new)
        y_new = L_val * np.sin(theta_new) * np.sin(psi_new)
        z_new = -L_val * np.cos(theta_new)
        vx_new = L_val * (
            theta_dot_new * np.cos(theta_new) * np.cos(psi_new)
            - phi_dot_new * np.sin(theta_new) * np.sin(psi_new)
        )
        vy_new = L_val * (
            theta_dot_new * np.cos(theta_new) * np.sin(psi_new)
            + phi_dot_new * np.sin(theta_new) * np.cos(psi_new)
        )
        vz_new = -L_val * theta_dot_new * np.sin(theta_new)

        kinetic_new = 0.5 * (L_val ** 2) * (
            theta_dot_new ** 2 + (np.sin(theta_new) ** 2) * phi_dot_new ** 2
        )
        potential_new = g_val * L_val * (1 - np.cos(theta_new))
        acceleration_new = (
            np.sin(theta_new) * np.cos(theta_new) * phi_dot_new ** 2
            - (g_val / L_val) * np.sin(theta_new)
            - drag_val * theta_dot_new * np.abs(theta_dot_new)
        )

        slice_from = slice(frame, None)
        theta[slice_from] = theta_new
        psi[slice_from] = psi_new
        theta_dot[slice_from] = theta_dot_new
        phi_dot[slice_from] = phi_dot_new
        pendulum_data["Energy"][slice_from] = energy_new
        pendulum_data["Kinetic"][slice_from] = kinetic_new
        pendulum_data["Potential"][slice_from] = potential_new
        pendulum_data["Angular acceleration"][slice_from] = acceleration_new
        x[slice_from] = x_new
        y[slice_from] = y_new
        z[slice_from] = z_new
        vx[slice_from] = vx_new
        vy[slice_from] = vy_new
        vz[slice_from] = vz_new

        force_x_var.set(0.0)
        force_y_var.set(0.0)
        force_z_var.set(0.0)

    options = ["RK4 Test 1", "RK4 Test 2", "RK4 Test 3", "Pendulum", "3D Pendulum"]
    option_var = tk.StringVar(value=options[0])

    # Top bar with main navigation buttons
    top_bar = ttk.Frame(root, padding=PADDING)
    top_bar.grid(row=0, column=0, columnspan=2, sticky="ew")
    top_bar.columnconfigure(0, weight=1)
    top_bar.columnconfigure(1, weight=1)
    top_bar.columnconfigure(2, weight=1)

    # Sidebar that slides in from the left
    sidebar = ttk.Frame(root, padding=PADDING)
    sidebar.place(x=0, y=top_bar.winfo_reqheight(), width=0, relheight=1.0)

    sidebar_container = ttk.Frame(sidebar)
    sidebar_container.pack(fill="both", expand=True)

    close_btn = ttk.Button(sidebar, text="Close", command=lambda: hide_sidebar())
    close_btn.pack(anchor="ne")

    desc_label = ttk.Label(sidebar, text="", justify="left", font=desc_font, wraplength=400)
    desc_label.pack(side="bottom", fill="x")

    sim_controls = ttk.Frame(sidebar_container)

    params_viz_container = ttk.Frame(sidebar_container)
    params_viz_container.columnconfigure(0, weight=1)
    params_viz_container.rowconfigure(0, weight=1)

    params_viz_frame = ttk.Frame(params_viz_container)
    params_viz_frame.grid(row=0, column=0, sticky="nsew")
    params_viz_frame.columnconfigure(0, weight=1)
    params_viz_frame.rowconfigure(0, weight=1)

    params_viz_canvas = tk.Canvas(
        params_viz_frame, background=DARK_BG, highlightthickness=0
    )
    params_viz_scrollbar = ttk.Scrollbar(
        params_viz_frame, orient="vertical", command=params_viz_canvas.yview
    )
    params_viz_canvas.configure(yscrollcommand=params_viz_scrollbar.set)

    params_viz_canvas.grid(row=0, column=0, sticky="nsew")
    params_viz_scrollbar.grid(row=0, column=1, sticky="ns")

    params_viz = ttk.Frame(params_viz_canvas)
    params_viz.columnconfigure(0, weight=1)
    _params_viz_window = params_viz_canvas.create_window(
        (0, 0), window=params_viz, anchor="nw"
    )

    def _configure_params_viz(event: tk.Event) -> None:
        params_viz_canvas.configure(scrollregion=params_viz_canvas.bbox("all"))

    params_viz.bind("<Configure>", _configure_params_viz)

    def _on_canvas_configure(event: tk.Event) -> None:
        params_viz_canvas.itemconfig(_params_viz_window, width=event.width)

    params_viz_canvas.bind("<Configure>", _on_canvas_configure)

    def _on_mousewheel(event: tk.Event) -> None:
        if event.delta:
            params_viz_canvas.yview_scroll(-int(event.delta / 120), "units")
        else:
            direction = -1 if event.num == 4 else 1
            params_viz_canvas.yview_scroll(direction, "units")

    def _bind_mousewheel(event: tk.Event) -> None:
        params_viz_canvas.bind_all("<MouseWheel>", _on_mousewheel)
        params_viz_canvas.bind_all("<Button-4>", _on_mousewheel)
        params_viz_canvas.bind_all("<Button-5>", _on_mousewheel)

    def _unbind_mousewheel(event: tk.Event) -> None:
        params_viz_canvas.unbind_all("<MouseWheel>")
        params_viz_canvas.unbind_all("<Button-4>")
        params_viz_canvas.unbind_all("<Button-5>")

    params_viz_canvas.bind("<Enter>", _bind_mousewheel)
    params_viz_canvas.bind("<Leave>", _unbind_mousewheel)

    export_controls = ttk.Frame(sidebar_container)
    export_controls.columnconfigure(0, weight=1)

    def show_sim():
        show_sidebar(sim_controls)

    def show_params():
        show_sidebar(params_viz_container)

    def show_export():
        show_sidebar(export_controls)

    sim_btn = ttk.Button(top_bar, text="Simulation and Visualisation", command=show_sim)
    sim_btn.grid(row=0, column=0, padx=PADDING, pady=PADDING)
    params_btn = ttk.Button(top_bar, text="Parameters", command=show_params)
    params_btn.grid(row=0, column=1, padx=PADDING, pady=PADDING)
    export_btn = ttk.Button(top_bar, text="Export", command=show_export)
    export_btn.grid(row=0, column=2, padx=PADDING, pady=PADDING)

    # Variables for pendulum parameters
    l_var = tk.DoubleVar(value=1.0)
    phi_var = tk.DoubleVar(value=np.degrees(0.1))  # polar angle
    psi_var = tk.DoubleVar(value=0.0)  # azimuth angle for 3D
    psi_dot_var = tk.DoubleVar(value=0.0)  # azimuth velocity for 3D
    g_var = tk.DoubleVar(value=9.81)
    h_var = tk.DoubleVar(value=0.01)
    drag_var = tk.DoubleVar(value=0.0)
    speed_var = tk.DoubleVar(value=1.0)
    show_vectors_var = tk.BooleanVar(value=False)

    force_x_var = tk.DoubleVar(value=0.0)
    force_y_var = tk.DoubleVar(value=0.0)
    force_z_var = tk.DoubleVar(value=0.0)
    show_trajectory_var = tk.BooleanVar(value=False)
    show_axes_var = tk.BooleanVar(value=True)
    fps_var = tk.StringVar(value="FPS: 0")


    graph_options = ["Angle", "Angular velocity", "Angular acceleration", "Energy"]
    graph_var = tk.StringVar(value=graph_options[0])

    # Simulation selection group inside the sidebar
    sim_frame = ttk.LabelFrame(
        sim_controls, text="Simulation", style="Black.TLabelframe"
    )
    sim_frame.grid(row=0, column=0, sticky="ew", padx=PADDING, pady=PADDING)
    sim_frame.columnconfigure(0, weight=1)
    dropdown = ttk.Combobox(sim_frame, textvariable=option_var, values=options, state="readonly")
    dropdown.grid(row=0, column=0, padx=PADDING, pady=PADDING, sticky="ew")

    viz_3d_frame = ttk.LabelFrame(sim_controls, text="3D Options")
    viz_3d_frame.grid(row=1, column=0, sticky="ew", padx=PADDING, pady=PADDING)
    viz_3d_frame.columnconfigure(0, weight=1)

    trajectory_check = ttk.Checkbutton(
        viz_3d_frame,
        text="Draw trajectory",
        variable=show_trajectory_var,
    )
    trajectory_check.grid(row=0, column=0, sticky="w", padx=5, pady=5)

    axes_check = ttk.Checkbutton(
        viz_3d_frame,
        text="Show axes",
        variable=show_axes_var,
    )
    axes_check.grid(row=1, column=0, sticky="w", padx=5, pady=5)

    reset_cam_btn = ttk.Button(
        viz_3d_frame, text="Reset camera", command=lambda: reset_camera()
    )
    reset_cam_btn.grid(row=2, column=0, sticky="w", padx=5, pady=5)

    sidebar_target_width = 0

    def animate_sidebar(opening: bool) -> None:
        nonlocal sidebar_target_width
        if opening and sidebar_target_width == 0:
            sidebar_target_width = int(root.winfo_width() * 0.3)
        current = sidebar.winfo_width()
        step = 20
        if opening:
            new_w = min(sidebar_target_width, current + step)
        else:
            new_w = max(0, current - step)
        x_pos = -sidebar_target_width + new_w
        y_pos = top_bar.winfo_height()
        sidebar.place(x=x_pos, y=y_pos, width=new_w, height=root.winfo_height() - y_pos)
        root.columnconfigure(0, minsize=new_w)
        if (opening and new_w < sidebar_target_width) or (not opening and new_w > 0):
            root.after(int(1000 / TARGET_FPS), animate_sidebar, opening)
        elif not opening:
            sidebar_target_width = 0

    def show_sidebar(frame: ttk.Frame) -> None:
        for child in sidebar_container.winfo_children():
            child.pack_forget()
        frame.pack(fill="both", expand=True)
        animate_sidebar(True)

    def hide_sidebar(event: tk.Event | None = None) -> None:
        animate_sidebar(False)

    root.bind("<Escape>", hide_sidebar)


    # Parameter controls grouped in a dedicated frame
    params_frame = ttk.LabelFrame(
        params_viz, text="Pendulum Parameters", style="Black.TLabelframe"
    )
    params_frame.grid(row=0, column=0, columnspan=3, sticky="ew", padx=PADDING, pady=PADDING)
    params_frame.columnconfigure(1, weight=1)

    def create_scale_entry(parent, text, var, row, tip, frm, to):
        label = ttk.Label(parent, text=text, font=slider_font)
        label.grid(row=row, column=0, sticky="w", padx=5, pady=5)
        scale = ttk.Scale(parent, variable=var, from_=frm, to=to, orient="horizontal")
        scale.grid(row=row, column=1, sticky="ew", padx=5, pady=5)
        entry = ttk.Entry(parent, textvariable=var, font=slider_font, width=8)
        entry.grid(row=row, column=2, sticky="ew", padx=5, pady=5)
        inputs.append(entry)
        Tooltip(scale, tip)
        Tooltip(entry, tip)

        def _update(*_args):
            try:
                val = float(var.get())
            except tk.TclError:
                return
            if scale.get() != val:
                scale.set(val)
            try:
                if float(entry.get()) != val:
                    entry.delete(0, tk.END)
                    entry.insert(0, f"{val:.3f}")
            except ValueError:
                entry.delete(0, tk.END)
                entry.insert(0, f"{val:.3f}")

        var.trace_add("write", _update)

        def _on_entry(event):
            try:
                var.set(float(entry.get()))
            except ValueError:
                pass

        entry.bind("<Return>", _on_entry)
        entry.bind("<FocusOut>", _on_entry)

        return label, scale, entry

    row = 0
    l_widgets = create_scale_entry(
        params_frame, "Länge [m]", l_var, row, "Pendellänge in Metern", 0.1, 10.0
    )
    row += 1
    phi_widgets = create_scale_entry(
        params_frame,
        "θ₀ [°]",
        phi_var,
        row,
        "Anfangspolarwinkel in Grad",
        -180,
        180,
    )
    row += 1
    g_widgets = create_scale_entry(
        params_frame,
        "g [m/s²]",
        g_var,
        row,
        "Gravitationsbeschleunigung",
        0,
        20,
    )
    row += 1
    h_widgets = create_scale_entry(
        params_frame,
        "Δt [s]",
        h_var,
        row,
        "Integrationszeitintervall",
        0.001,
        0.1,
    )
    row += 1
    drag_widgets = create_scale_entry(
        params_frame,
        "b [-]",
        drag_var,
        row,
        "Luftwiderstandskoeffizient",
        0,
        1,
    )
    row += 1
    speed_widgets = create_scale_entry(
        params_frame,
        "s [-]",
        speed_var,
        row,
        "Simulationsgeschwindigkeit",
        0.1,
        5,
    )
    row += 1
    psi_widgets = create_scale_entry(
        params_frame,
        "ψ₀ [°]",
        psi_var,
        row,
        "Initialer Azimutwinkel",
        -180,
        180,
    )
    row += 1
    psi_dot_widgets = create_scale_entry(
        params_frame,
        "ψ̇₀ [°/s]",
        psi_dot_var,
        row,
        "Initiale Azimutwinkelgeschwindigkeit",
        -360,
        360,
    )
    row += 1

    fx_widgets = create_scale_entry(
        params_frame,
        "P_x [N·s]",
        force_x_var,
        row,
        "Impuls entlang der x-Achse",
        -10,
        10,
    )
    row += 1
    fy_widgets = create_scale_entry(
        params_frame,
        "P_y [N·s]",
        force_y_var,
        row,
        "Impuls entlang der y-Achse",
        -10,
        10,
    )
    row += 1
    fz_widgets = create_scale_entry(
        params_frame,
        "P_z [N·s]",
        force_z_var,
        row,
        "Impuls entlang der z-Achse",
        -10,
        10,
    )
    row += 1

    apply_impulse_btn = ttk.Button(
        params_frame, text="Impuls anwenden", command=apply_impulse
    )
    apply_impulse_btn.grid(row=row, column=0, columnspan=3, padx=5, pady=5, sticky="ew")
    row += 1

    three_d_widgets = [
        psi_widgets[0],
        psi_widgets[1],
        psi_widgets[2],
        psi_dot_widgets[0],
        psi_dot_widgets[1],
        psi_dot_widgets[2],
        fx_widgets[0],
        fx_widgets[1],
        fx_widgets[2],
        fy_widgets[0],
        fy_widgets[1],
        fy_widgets[2],
        fz_widgets[0],
        fz_widgets[1],
        fz_widgets[2],
        apply_impulse_btn,
    ]
    viz_frame = ttk.LabelFrame(params_viz, text="Visualization Options")
    viz_frame.grid(row=1, column=0, columnspan=3, padx=PADDING, pady=PADDING, sticky="ew")
    viz_frame.columnconfigure(0, weight=1)

    graph_dropdown = ttk.Combobox(viz_frame, textvariable=graph_var,
                                  values=graph_options, state="readonly")
    graph_dropdown.grid(row=0, column=0, sticky="w", padx=5, pady=5)

    show_vectors_check = ttk.Checkbutton(
        viz_frame, text="Force vectors", variable=show_vectors_var
    )
    show_vectors_check.grid(row=1, column=0, sticky="w", padx=5, pady=5)

    # Action buttons
    action_frame = ttk.Frame(sim_controls)
    action_frame.grid(row=2, column=0, padx=PADDING, pady=PADDING, sticky="ew")
    action_frame.columnconfigure(0, weight=1)

    # Description placed at the bottom of the sidebar
    desc_text_default = (
        "Adjust parameters using the inputs above and press Run to start the "
        "simulation. The pendulum animation appears in the top-right quadrant "
        "while the chosen quantity is plotted below it."
    )
    desc_text_pend = (
        "L: pendulum length\n"
        "θ₀: initial polar angle (deg)\n"
        "g: gravitational acceleration\n"
        "h: time step\n"
        "b: air resistance coefficient\n"
        "s: animation speed"
    )
    desc_text_pend3d = (
        desc_text_pend + "\n"
        "ψ₀: initial azimuth angle (deg)\n"
        "ψ̇₀: initial azimuth angular velocity (deg/s)\n"
        "P_x: impulse along x\n"
        "P_y: impulse along y\n"
        "P_z: impulse along z"
    )

    desc_label.configure(text=desc_text_default)

    # Right column for 3D view and diagrams
    display_frame = ttk.Frame(root)
    display_frame.grid(row=1, column=1, sticky="nsew")
    display_frame.columnconfigure(0, weight=1)
    display_frame.rowconfigure(0, weight=3)
    display_frame.rowconfigure(1, weight=2)

    # Top: 3D canvas, Bottom: diagram area
    anim_frame = ttk.Frame(display_frame)
    anim_frame.grid(row=0, column=0, sticky="nsew")
    plot_frame = ttk.Frame(display_frame)
    plot_frame.grid(row=1, column=0, sticky="nsew")

    # Use a larger default figure size for better visibility and make sure the
    # canvas fills the available space in the frame. Start without a 3D axis –
    # it will be created on demand depending on the selected module.
    fig_anim = plt.figure(figsize=(10, 8))
    fig_anim.patch.set_facecolor(DARK_BG)
    ax_anim = fig_anim.add_subplot(111)
    ax_anim.set_facecolor(AX_BG)
    default_elev, default_azim = 30, -60
    canvas_anim = FigureCanvasTkAgg(fig_anim, master=anim_frame)
    canvas_anim.get_tk_widget().pack(expand=True, fill="both", padx=5, pady=5)

    def reset_camera() -> None:
        if ax_anim and hasattr(ax_anim, "view_init"):
            ax_anim.view_init(default_elev, default_azim)
        canvas_anim.draw_idle()

    fig_plot, ax_plot = plt.subplots(figsize=(6, 5))
    fig_plot.patch.set_facecolor(DARK_BG)
    canvas_plot = FigureCanvasTkAgg(fig_plot, master=plot_frame)
    canvas_plot.get_tk_widget().pack(expand=True, fill="both", padx=PADDING, pady=PADDING)

    theta_line = psi_line = None

    def update_inputs(*args):
        """Enable or disable controls based on the selected module."""
        nonlocal ax_anim, has_run
        selection = option_var.get()
        pendulum_selected = selection in ("Pendulum", "3D Pendulum")
        has_run = False
        if run_play_btn is not None:
            run_play_btn.configure(text="Run")

        if pendulum_selected:
            anim_frame.grid()
            fig_anim.clf()
            fig_anim.patch.set_facecolor(DARK_BG)
            if selection == "3D Pendulum":
                ax_anim = fig_anim.add_subplot(111, projection="3d")
                ax_anim.view_init(default_elev, default_azim)
                limit = l_var.get() * 1.2
                ax_anim.set_xlim(-limit, limit)
                ax_anim.set_ylim(-limit, limit)
                ax_anim.set_zlim(-limit, limit)
                ax_anim.set_box_aspect([1, 1, 1])
            else:
                ax_anim = fig_anim.add_subplot(111)
            ax_anim.set_facecolor(AX_BG)
            state = tk.NORMAL
            if selection == "3D Pendulum":
                desc_label.configure(text=desc_text_pend3d)
            else:
                desc_label.configure(text=desc_text_pend)
        else:
            anim_frame.grid_remove()
            fig_anim.clf()
            ax_anim = None
            state = tk.DISABLED
            desc_label.configure(text=desc_text_default)
        set_state_recursive(params_frame, state)
        set_state_recursive(viz_frame, state)
        set_state_recursive(viz_3d_frame, state)

        if pendulum_selected:
            graph_dropdown.configure(state="readonly")
            show_vectors_check.configure(state=tk.NORMAL)
        else:
            graph_dropdown.configure(state=tk.DISABLED)
            show_vectors_check.configure(state=tk.DISABLED)
            show_vectors_var.set(False)

        if selection == "3D Pendulum":
            for w in three_d_widgets:
                w.grid()
            viz_3d_frame.grid()
            trajectory_check.configure(state=tk.NORMAL)
            axes_check.configure(state=tk.NORMAL)
            reset_cam_btn.configure(state=tk.NORMAL)
        else:
            for w in three_d_widgets:
                w.grid_remove()
            viz_3d_frame.grid_remove()
            trajectory_check.configure(state=tk.DISABLED)
            axes_check.configure(state=tk.DISABLED)
            reset_cam_btn.configure(state=tk.DISABLED)


    option_var.trace_add("write", update_inputs)
    update_inputs()

    def update_graph(*args):
        nonlocal screenshot_taken
        if option_var.get() in ("Pendulum", "3D Pendulum") and pendulum_data is not None:
            ax_plot.clear()
            ax_plot.set_facecolor(AX_BG)
            if option_var.get() == "3D Pendulum" and graph_var.get() == "Angle":
                init_plot()

            # Keep pendulum animation in ani[0] if available
            pend_anim = ani[0] if ani else None
            ani.clear()
            if pend_anim:
                ani.append(pend_anim)

            screenshot_taken = False
            if graph_var.get() == "Energy":
                # Animate total, kinetic and potential energy together
                t = pendulum_data["t"]
                total = pendulum_data["Energy"]
                kinetic = pendulum_data["Kinetic"]
                potential = pendulum_data["Potential"]
                min_val = min(np.min(total), np.min(kinetic), np.min(potential))
                max_val = max(np.max(total), np.max(kinetic), np.max(potential))
                ani_line = animate_energy(fig_plot, ax_plot, t, kinetic,
                                          potential, total, speed_var.get(),
                                          (min_val, max_val))
            elif option_var.get() == "3D Pendulum" and graph_var.get() == "Angle":
                ani_line = animate_angles(
                    pendulum_data["t"],
                    pendulum_data["Angle"],
                    pendulum_data["Psi"],
                    speed_var.get(),
                    (-3.5, 3.5),
                )
            elif option_var.get() == "Pendulum" and graph_var.get() == "Angle":
                ani_line = animate_two_lines(
                    fig_plot,
                    ax_plot,
                    pendulum_data["t"],
                    pendulum_data["Angle"],
                    pendulum_data["Sine"],
                    speed_var.get(),
                    (-2.5, 2.5),
                    labels=("φ", "Sin(t)"),
                )
            else:
                dataset = pendulum_data.get(graph_var.get(), pendulum_data["Angle"])
                y_range = (-3.5, 3.5) if graph_var.get() == "Angle" else None
                ani_line = animate_line(
                    fig_plot,
                    ax_plot,
                    pendulum_data["t"],
                    dataset,
                    speed_var.get(),
                    y_range,
                )
            
            ani.append(ani_line)
            ax_plot.set_xlabel('t')
            ax_plot.set_ylabel('Angle' if graph_var.get() == "Angle" else graph_var.get())
            canvas_plot.draw()

    graph_var.trace_add("write", update_graph)

    def init_plot():
        nonlocal theta_line, psi_line
        ax_plot.clear()
        ax_plot.set_facecolor(AX_BG)
        theta_line, = ax_plot.plot([], [], color="cyan", label="θ(t)")
        psi_line, = ax_plot.plot([], [], color="magenta", label="ψ(t)")
        ax_plot.set_xlabel("Zeit [s]")
        ax_plot.set_ylabel("Winkel [rad]")
        ax_plot.grid(color="#333333")
        legend = ax_plot.legend(facecolor=DARK_BG, edgecolor=FG_COLOR)
        legend.get_frame().set_alpha(0.5)
        ax_plot.tick_params(colors=FG_COLOR)
        for spine in ax_plot.spines.values():
            spine.set_edgecolor(FG_COLOR)

    init_plot()

    # Placeholder handlers for future zoom and tooltip features
    def _on_zoom(_event):
        """Zoom placeholder."""
        pass

    def _show_tooltip(_event):
        """Tooltip placeholder."""
        pass

    fig_plot.canvas.mpl_connect("scroll_event", _on_zoom)
    fig_plot.canvas.mpl_connect("motion_notify_event", _show_tooltip)

    ani = []

    # Determine whether the current Matplotlib backend supports blitting.
    # TkAgg does not support blitting, whereas other interactive backends
    # (e.g., QtAgg) do. Retrieve the backend once and reuse the result for
    # all animations defined below.
    blit = matplotlib.get_backend() != "TkAgg"

    def animate_line(fig, ax, t, y, speed, y_range=None):
        """Animate a line plot on the given axes."""
        line, = ax.plot([], [], 'b-')
        ax.set_xlim(t[0], t[-1])
        if y_range is None:
            ax.set_ylim(min(y), max(y))
        else:
            ax.set_ylim(*y_range)
        ax.set_xlabel('t')
        ax.set_ylabel('y')
        ax.set_title('Animation')

        def init():
            line.set_data([], [])
            return line,

        last_time = time.time()

        def update(frame):
            nonlocal last_time
            if not running:
                return line,
            start_idx = 0
            current = time.time()
            dt = current - last_time
            if dt > 0:
                fps = 1.0 / dt
                fps_var.set(f"FPS: {fps:.1f}")
                if dt > 1.0 / TARGET_FPS:
                    start_idx = max(0, frame - MAX_TRAIL_POINTS)
            line.set_data(t[start_idx:frame], y[start_idx:frame])
            if frame == len(t) - 1:
                root.after(0, auto_screenshot)
            last_time = current
            return line,

        interval = max(1, int(1000 / (TARGET_FPS * speed)))
        return animation.FuncAnimation(
            fig,
            update,
            frames=len(t),
            init_func=init,
            blit=blit,
            interval=interval,
            repeat=False,
        )

    def animate_angles(t, theta, psi, speed, y_range=None):
        """Animate θ and ψ using the pre-created lines."""
        ax_plot.set_xlim(t[0], t[-1])
        if y_range is None:
            min_val = min(np.min(theta), np.min(psi))
            max_val = max(np.max(theta), np.max(psi))
            ax_plot.set_ylim(min_val, max_val)
        else:
            ax_plot.set_ylim(*y_range)

        def init():
            theta_line.set_data([], [])
            psi_line.set_data([], [])
            return theta_line, psi_line

        last_time = time.time()

        def update(frame):
            nonlocal last_time
            if not running:
                return theta_line, psi_line
            start_idx = 0
            current = time.time()
            dt = current - last_time
            if dt > 0:
                fps = 1.0 / dt
                fps_var.set(f"FPS: {fps:.1f}")
                if dt > 1.0 / TARGET_FPS:
                    start_idx = max(0, frame - MAX_TRAIL_POINTS)
            theta_line.set_data(t[start_idx:frame], theta[start_idx:frame])
            psi_line.set_data(t[start_idx:frame], psi[start_idx:frame])
            if frame == len(t) - 1:
                root.after(0, auto_screenshot)
            last_time = current
            return theta_line, psi_line

        interval = max(1, int(1000 / (TARGET_FPS * speed)))
        return animation.FuncAnimation(
            fig_plot,
            update,
            frames=len(t),
            init_func=init,
            blit=blit,
            interval=interval,
            repeat=False,
        )

    def animate_two_lines(
        fig, ax, t, y1, y2, speed, y_range=None, labels=("θ", "ψ")
    ):
        """Animate two line plots for comparing two datasets."""
        line1, = ax.plot([], [], color="purple", label=labels[0])
        line2, = ax.plot([], [], color="red", label=labels[1])
        ax.set_xlim(t[0], t[-1])
        if y_range is None:
            min_val = min(np.min(y1), np.min(y2))
            max_val = max(np.max(y1), np.max(y2))
            ax.set_ylim(min_val, max_val)
        else:
            ax.set_ylim(*y_range)
        ax.set_xlabel('t')
        ax.set_ylabel('Angle')
        ax.set_title('Animation')
        ax.legend()

        def init():
            line1.set_data([], [])
            line2.set_data([], [])
            return line1, line2

        last_time = time.time()

        def update(frame):
            nonlocal last_time
            if not running:
                return line1, line2
            start_idx = 0
            current = time.time()
            dt = current - last_time
            if dt > 0:
                fps = 1.0 / dt
                fps_var.set(f"FPS: {fps:.1f}")
                if dt > 1.0 / TARGET_FPS:
                    start_idx = max(0, frame - MAX_TRAIL_POINTS)
            line1.set_data(t[start_idx:frame], y1[start_idx:frame])
            line2.set_data(t[start_idx:frame], y2[start_idx:frame])
            if frame == len(t) - 1:
                root.after(0, auto_screenshot)
            last_time = current
            return line1, line2

        interval = max(1, int(1000 / (TARGET_FPS * speed)))
        return animation.FuncAnimation(
            fig,
            update,
            frames=len(t),
            init_func=init,
            blit=blit,
            interval=interval,
            repeat=False,
        )

    def animate_pendulum(fig, ax, t, phi, L, speed):
        ax.clear()
        x = L * np.sin(phi)
        y = -L * np.cos(phi)
        line, = ax.plot([], [], 'o-', lw=2, markersize=15)
        ax.set_xlim(-L * 1.2, L * 1.2)
        ax.set_ylim(-L * 1.2, L * 0.2)
        ax.set_aspect('equal', adjustable='box')
        ax.set_title('Pendulum')

        def init():
            line.set_data([], [])
            return line,

        last_time = time.time()

        def update(frame):
            nonlocal last_time
            if not running:
                return line,
            line.set_data([0, x[frame]], [0, y[frame]])
            if frame == len(t) - 1:
                root.after(0, auto_screenshot)
            current = time.time()
            dt = current - last_time
            if dt > 0:
                fps_var.set(f"FPS: {1.0 / dt:.1f}")
            last_time = current
            return line,

        interval = max(1, int(1000 / (TARGET_FPS * speed)))
        return animation.FuncAnimation(
            fig,
            update,
            frames=len(t),
            init_func=init,
            blit=blit,
            interval=interval,
            repeat=False,
        )

    def animate_pendulum3d(
        fig,
        ax,
        t,
        x,
        y,
        z,
        vx,
        vy,
        vz,
        L,
        g,
        speed,
        show_trajectory=False,
        show_vectors=False,
        applied_force=None,
        show_axes=True,
    ):
        """Animate a 3D pendulum given Cartesian position and velocity arrays.

        The function now works directly with ``x, y, z`` coordinates and their
        corresponding velocities ``vx, vy, vz``. Force vectors (gravity, tension
        and an optional applied force) are computed using vector operations
        instead of angular quantities.
        """

        ax.clear()
        if not show_axes:
            ax.set_axis_off()
        else:
            ax.set_axis_on()
        line, = ax.plot([], [], [], "o-", lw=2, markersize=8)
        arrows = []
        limit = L * 1.2
        ax.set_xlim(-limit, limit)
        ax.set_ylim(-limit, limit)
        ax.set_zlim(-limit, limit)
        ax.set_box_aspect([1, 1, 1])
        ax.set_title("3D Pendulum")
        line_xy, = ax.plot([], [], [], color="white", lw=1, alpha=0.5)
        line_yz, = ax.plot([], [], [], color="white", lw=1, alpha=0.5)
        line_zx, = ax.plot([], [], [], color="white", lw=1, alpha=0.5)

        # Precompute accelerations from velocity arrays
        ax_vals = np.gradient(vx, t, edge_order=2)
        ay_vals = np.gradient(vy, t, edge_order=2)
        az_vals = np.gradient(vz, t, edge_order=2)

        def init():
            line.set_data([], [])
            line.set_3d_properties([])
            line_xy.set_data([], [])
            line_xy.set_3d_properties([])
            line_yz.set_data([], [])
            line_yz.set_3d_properties([])
            line_zx.set_data([], [])
            line_zx.set_3d_properties([])
            return line, line_xy, line_yz, line_zx

        last_time = time.time()

        def update(frame):
            nonlocal last_time
            if not running:
                return tuple()
            line.set_data([0, x[frame]], [0, y[frame]])
            line.set_3d_properties([0, z[frame]])

            for arr in arrows:
                arr.remove()
            arrows.clear()

            if show_vectors:
                r_vec = np.array([x[frame], y[frame], z[frame]])
                r_hat = r_vec / np.linalg.norm(r_vec)
                v_vec = np.array([vx[frame], vy[frame], vz[frame]])
                a_vec = np.array([ax_vals[frame], ay_vals[frame], az_vals[frame]])

                f_vec = (
                    applied_force[frame]
                    if applied_force is not None
                    else np.zeros(3)
                )

                g_vec = np.array([0.0, 0.0, -g])

                # tension (mass = 1); project forces onto radial direction
                T = g_vec.dot(r_hat) - a_vec.dot(r_hat) - f_vec.dot(r_hat)
                t_vec = -T * r_hat

                force_scale = 0.3 * L / g if g != 0 else 0.3 * L

                arrows.append(
                    ax.quiver(
                        x[frame],
                        y[frame],
                        z[frame],
                        g_vec[0],
                        g_vec[1],
                        g_vec[2],
                        length=force_scale,
                        normalize=False,
                        color="blue",
                    )
                )
                arrows.append(
                    ax.quiver(
                        x[frame],
                        y[frame],
                        z[frame],
                        t_vec[0],
                        t_vec[1],
                        t_vec[2],
                        length=force_scale,
                        normalize=False,
                        color="red",
                    )
                )
                if applied_force is not None:
                    arrows.append(
                        ax.quiver(
                            x[frame],
                            y[frame],
                            z[frame],
                            f_vec[0],
                            f_vec[1],
                            f_vec[2],
                            length=force_scale,
                            normalize=False,
                            color="green",
                        )
                    )

            start_idx = 0

            current = time.time()
            dt = current - last_time
            if dt > 0:
                fps = 1.0 / dt
                fps_var.set(f"FPS: {fps:.1f}")
                if dt > 1.0 / TARGET_FPS:
                    start_idx = max(0, frame + 1 - MAX_TRAIL_POINTS)
            last_time = current

            if show_trajectory:
                line_xy.set_data(x[start_idx:frame+1], y[start_idx:frame+1])
                line_xy.set_3d_properties(np.full(frame + 1 - start_idx, -limit))
                line_yz.set_data(np.full(frame + 1 - start_idx, limit), y[start_idx:frame+1])
                line_yz.set_3d_properties(z[start_idx:frame+1])
                line_zx.set_data(x[start_idx:frame+1], np.full(frame + 1 - start_idx, -limit))
                line_zx.set_3d_properties(z[start_idx:frame+1])
                artists = [line, line_xy, line_yz, line_zx, *arrows]
            else:
                artists = [line, *arrows]

            if frame == len(t) - 1:
                root.after(0, auto_screenshot)

            if pendulum_data is not None:
                pendulum_data["frame"] = frame

            return tuple(artists)


        interval = max(1, int(1000 / (TARGET_FPS * speed)))
        return animation.FuncAnimation(
            fig,
            update,
            frames=len(t),
            init_func=init,
            blit=False,
            interval=interval,
            repeat=False,
        )

    def animate_energy(fig, ax, t, kinetic, potential, total, speed,
                       y_range=None):
        """Animate kinetic, potential and total energy lines together."""
        line_k, = ax.plot([], [], color="blue", label="Kinetic")
        line_p, = ax.plot([], [], color="red", label="Potential")
        line_t, = ax.plot([], [], color="white", label="Total")
        ax.set_xlim(t[0], t[-1])
        if y_range is None:
            y_min = min(np.min(kinetic), np.min(potential), np.min(total))
            y_max = max(np.max(kinetic), np.max(potential), np.max(total))
            ax.set_ylim(y_min, y_max)
        else:
            ax.set_ylim(*y_range)
        ax.set_xlabel('t')
        ax.set_ylabel('Energy')
        ax.set_title('Energy')
        ax.legend()

        def init():
            line_k.set_data([], [])
            line_p.set_data([], [])
            line_t.set_data([], [])
            return line_k, line_p, line_t

        last_time = time.time()

        def update(frame):
            nonlocal last_time
            if not running:
                return line_k, line_p, line_t
            start_idx = 0
            current = time.time()
            dt = current - last_time
            if dt > 0:
                fps = 1.0 / dt
                fps_var.set(f"FPS: {fps:.1f}")
                if dt > 1.0 / TARGET_FPS:
                    start_idx = max(0, frame - MAX_TRAIL_POINTS)
            line_k.set_data(t[start_idx:frame], kinetic[start_idx:frame])
            line_p.set_data(t[start_idx:frame], potential[start_idx:frame])
            line_t.set_data(t[start_idx:frame], total[start_idx:frame])
            if frame == len(t) - 1:
                root.after(0, auto_screenshot)
            last_time = current
            return line_k, line_p, line_t

        interval = max(1, int(1000 / (TARGET_FPS * speed)))
        return animation.FuncAnimation(
            fig,
            update,
            frames=len(t),
            init_func=init,
            blit=blit,
            interval=interval,
            repeat=False,
        )

    pendulum_data = None

    def setup_rk4_test1():
        nonlocal ax_anim
        fig_anim.clf()
        fig_anim.patch.set_facecolor(DARK_BG)
        ax_anim = fig_anim.add_subplot(111)
        ax_anim.set_facecolor(AX_BG)
        import rk4_test1 as mod
        t, y = mod.run(ax=ax_plot)
        anim = animate_line(fig_anim, ax_anim, t, y, speed_var.get())
        return [anim], None

    def setup_rk4_test2():
        nonlocal ax_anim
        fig_anim.clf()
        fig_anim.patch.set_facecolor(DARK_BG)
        ax_anim = fig_anim.add_subplot(111)
        ax_anim.set_facecolor(AX_BG)
        import rk4_test2 as mod
        t, y = mod.run(ax=ax_plot)
        anim = animate_line(fig_anim, ax_anim, t, y, speed_var.get())
        return [anim], None

    def setup_rk4_test3():
        nonlocal ax_anim
        fig_anim.clf()
        fig_anim.patch.set_facecolor(DARK_BG)
        ax_anim = fig_anim.add_subplot(111)
        ax_anim.set_facecolor(AX_BG)
        import rk4_test3 as mod
        t, x, _ = mod.run(ax=ax_plot)
        anim = animate_line(fig_anim, ax_anim, t, x, speed_var.get())
        return [anim], None

    def setup_pendulum():
        import pendulum as mod
        t, phi, omega, energy = mod.run(
            L=l_var.get(),
            phi0=np.radians(phi_var.get()),
            g=g_var.get(),
            h=h_var.get(),
            air_resistance=drag_var.get(),
            plot=False,
        )
        L_val = l_var.get()
        g_val = g_var.get()
        drag_val = drag_var.get()
        kinetic = 0.5 * (L_val ** 2) * omega ** 2
        potential = g_val * L_val * (1 - np.cos(phi))
        acceleration = (
            -(g_val / L_val) * np.sin(phi) - drag_val * omega * np.abs(omega)
        )
        sine = np.sin(L_val * t)
        max_amp = max(np.max(np.abs(phi)), np.max(np.abs(sine)))
        pendulum = {
            "t": t,
            "Angle": phi,
            "Sine": sine,
            "Angular velocity": omega,
            "Angular acceleration": acceleration,
            "Energy": energy,
            "Kinetic": kinetic,
            "Potential": potential,
        }
        animations = [
            animate_pendulum(fig_anim, ax_anim, t, phi, l_var.get(), speed_var.get())
        ]
        dataset = pendulum.get(graph_var.get(), pendulum["Angle"])
        if graph_var.get() == "Energy":
            min_val = min(np.min(dataset), np.min(kinetic), np.min(potential))
            max_val = max(np.max(dataset), np.max(kinetic), np.max(potential))
            animations.append(
                animate_energy(
                    fig_plot,
                    ax_plot,
                    t,
                    kinetic,
                    potential,
                    dataset,
                    speed_var.get(),
                    (min_val, max_val),
                )
            )
        elif graph_var.get() == "Angle":
            animations.append(
                animate_two_lines(
                    fig_plot,
                    ax_plot,
                    t,
                    phi,
                    sine,
                    speed_var.get(),
                    (-max_amp, max_amp),
                    labels=("θ", "Sine"),
                )
            )
        else:
            animations.append(
                animate_line(fig_plot, ax_plot, t, dataset, speed_var.get())
            )
        ax_plot.set_xlabel('t')
        ax_plot.set_ylabel(graph_var.get())
        return animations, pendulum

    def setup_pendulum3d():
        import pendulum3d as mod
        ax_anim.view_init(default_elev, default_azim)
        (
            t,
            theta,
            psi,
            theta_dot,
            phi_dot,
            energy,
        ) = mod.run(
            L=l_var.get(),
            theta0=np.radians(phi_var.get()),
            phi0=np.radians(psi_var.get()),
            phi_dot0=np.radians(psi_dot_var.get()),
            g=g_var.get(),
            h=h_var.get(),
            air_resistance=drag_var.get(),
            force_x=force_x_var.get(),
            force_y=force_y_var.get(),
            force_z=force_z_var.get(),
            plot=False,
        )
        L_val = l_var.get()
        g_val = g_var.get()
        drag_val = drag_var.get()
        x = L_val * np.sin(theta) * np.cos(psi)
        y = L_val * np.sin(theta) * np.sin(psi)
        z = -L_val * np.cos(theta)
        vx = L_val * (
            theta_dot * np.cos(theta) * np.cos(psi)
            - phi_dot * np.sin(theta) * np.sin(psi)
        )
        vy = L_val * (
            theta_dot * np.cos(theta) * np.sin(psi)
            + phi_dot * np.sin(theta) * np.cos(psi)
        )
        vz = -L_val * theta_dot * np.sin(theta)
        max_amp = max(np.max(np.abs(theta)), np.max(np.abs(psi)))
        kinetic = 0.5 * (L_val ** 2) * (
            theta_dot ** 2 + (np.sin(theta) ** 2) * phi_dot ** 2
        )
        potential = g_val * L_val * (1 - np.cos(theta))
        acceleration = (
            np.sin(theta) * np.cos(theta) * phi_dot ** 2
            - (g_val / L_val) * np.sin(theta)
            - drag_val * theta_dot * np.abs(theta_dot)
        )
        pendulum = {
            "t": t,
            "Angle": theta,
            "Psi": psi,
            "Angular velocity": theta_dot,
            "phi_dot": phi_dot,
            "Angular acceleration": acceleration,
            "Energy": energy,
            "Kinetic": kinetic,
            "Potential": potential,
            "x": x,
            "y": y,
            "z": z,
            "vx": vx,
            "vy": vy,
            "vz": vz,
        }
        applied = None
        if show_vectors_var.get() and (
            force_x_var.get() or force_y_var.get() or force_z_var.get()
        ):
            applied = np.tile(
                [force_x_var.get(), force_y_var.get(), force_z_var.get()],
                (len(t), 1),
            )
        animations = [
            animate_pendulum3d(
                fig_anim,
                ax_anim,
                t,
                x,
                y,
                z,
                vx,
                vy,
                vz,
                l_var.get(),
                g_val,
                speed_var.get(),
                show_trajectory_var.get(),
                show_vectors_var.get(),
                applied,
                show_axes_var.get(),
            )
        ]
        dataset = pendulum.get(graph_var.get(), pendulum["Angle"])
        if graph_var.get() == "Energy":
            min_val = min(np.min(dataset), np.min(kinetic), np.min(potential))
            max_val = max(np.max(dataset), np.max(kinetic), np.max(potential))
            animations.append(
                animate_energy(
                    fig_plot,
                    ax_plot,
                    t,
                    kinetic,
                    potential,
                    dataset,
                    speed_var.get(),
                    (min_val, max_val),
                )
            )
        elif graph_var.get() == "Angle":
            animations.append(
                animate_angles(
                    t,
                    theta,
                    psi,
                    speed_var.get(),
                    (-max_amp, max_amp),
                )
            )
        else:
            animations.append(
                animate_line(fig_plot, ax_plot, t, dataset, speed_var.get())
            )
        ax_plot.set_xlabel('t')
        ax_plot.set_ylabel('Angle' if graph_var.get() == "Angle" else graph_var.get())
        return animations, pendulum

    simulation_setup = {
        "RK4 Test 1": setup_rk4_test1,
        "RK4 Test 2": setup_rk4_test2,
        "RK4 Test 3": setup_rk4_test3,
        "Pendulum": setup_pendulum,
        "3D Pendulum": setup_pendulum3d,
    }

    def run_selected():
        nonlocal ani, pendulum_data, screenshot_taken
        screenshot_taken = False
        selection = option_var.get()
        ax_plot.clear()
        ax_plot.set_facecolor(AX_BG)
        if selection == "3D Pendulum" and graph_var.get() == "Angle":
            init_plot()
        for a in ani:
            a.event_source.stop()
        ani.clear()
        pendulum_data = None
        fps_var.set("FPS: 0")
        setup_func = simulation_setup.get(selection)
        if setup_func is not None:
            new_ani, pendulum_data = setup_func()
            ani.extend(new_ani)
        canvas_anim.draw()
        canvas_plot.draw()
    def start_sim() -> None:
        nonlocal running
        running = True
        for a in ani:
            a.event_source.start()
        root.update_idletasks()

    def pause_sim() -> None:
        nonlocal running
        running = False
        for a in ani:
            a.event_source.stop()
        run_play_btn.configure(text="Play")
        root.update_idletasks()

    def reset_sim() -> None:
        nonlocal running, has_run
        running = False
        for a in ani:
            a.event_source.stop()
        run_selected()
        has_run = False
        run_play_btn.configure(text="Run")
        root.update_idletasks()

    def step_sim() -> None:
        for a in ani:
            a.event_source.stop()
            a._step()
        canvas_anim.draw()
        canvas_plot.draw()

    def set_speed(value: float) -> None:
        speed_var.set(value)

    def run_or_play() -> None:
        nonlocal has_run
        if not has_run:
            run_selected()
            start_sim()
            has_run = True
            run_play_btn.configure(text="Play")
        else:
            start_sim()

    run_play_btn = ttk.Button(action_frame, text="Run", command=run_or_play)
    run_play_btn.grid(row=0, column=0, padx=PADDING, pady=PADDING, sticky="ew")
    pause_btn = ttk.Button(action_frame, text="Pause", command=pause_sim)
    pause_btn.grid(row=1, column=0, padx=PADDING, pady=PADDING, sticky="ew")
    reset_btn = ttk.Button(action_frame, text="Reset", command=reset_sim)
    reset_btn.grid(row=2, column=0, padx=PADDING, pady=PADDING, sticky="ew")
    step_btn = ttk.Button(action_frame, text="Step", command=step_sim)
    step_btn.grid(row=3, column=0, padx=PADDING, pady=PADDING, sticky="ew")
    speed_dropdown = ttk.Combobox(
        action_frame,
        textvariable=speed_var,
        values=[0.5, 1.0, 2.0, 4.0],
        state="readonly",
    )
    speed_dropdown.grid(row=4, column=0, padx=PADDING, pady=PADDING, sticky="ew")
    speed_dropdown.bind(
        "<<ComboboxSelected>>", lambda e: set_speed(speed_var.get())
    )

    fps_label = ttk.Label(action_frame, textvariable=fps_var)
    fps_label.grid(row=5, column=0, padx=PADDING, pady=PADDING, sticky="w")

    pendulum_export_button = ttk.Button(
        export_controls, text="Pendel exportieren", command=export_pendulum
    )
    pendulum_export_button.grid(row=0, column=0, padx=PADDING, pady=PADDING, sticky="ew")

    diagram_export_button = ttk.Button(
        export_controls, text="Diagramm exportieren", command=export_plot
    )
    diagram_export_button.grid(row=1, column=0, padx=PADDING, pady=PADDING, sticky="ew")

    btn_width = min(
        MAX_BUTTON_WIDTH,
        max(1, root.winfo_width() // 30)
    )
    pendulum_export_button.configure(width=btn_width)
    diagram_export_button.configure(width=btn_width)

    root.mainloop()


if __name__ == "__main__":
    main()

